<!DOCTYPE html>
<html>

    <head>
<meta charset="utf-8" />
<meta name="baidu-site-verification" content="KGkHBH2V5C" />
<meta name="uyan_auth" content="a46c4fcaad" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>C++ Primer 学习笔记</title>
<meta name="description" content="">

<link rel="stylesheet" href="/css/bootstrap.min.css">
<link rel="stylesheet" href="/font/font-awesome-4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" media="all" href="/css/style.css" />
<link rel="stylesheet" type="text/css" media="all" href="/css/jquery.mmenu.all.css" />
<link rel="stylesheet" href="/css/highlightjs.piperita.css">


<link rel="apple-touch-icon" sizes="57x57" href="/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/favicons/manifest.json">
<link rel="shortcut icon" href="/favicons/favicon.ico">
<script src="/js/jquery-1.11.0.mini.js"></script>
<script src="/js/jquery.query.js"></script>

<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-TileImage" content="/favicons/mstile-144x144.png">
<meta name="msapplication-config" content="/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">




</head>


    <body>

    <nav id="my-menu">
  <div>
    <a class="my-home"><h1>ychost</h1></a>

    <ul class="pages">
      <li><a href="/"> <i class="fa fa-home"></i> 主页</a></li>
      <li><a href="/posts/"><i class="fa fa-archive"></i> 文章</a></li>
      <li><a href="/search/"><i class="fa fa-search"></i> 搜索</a></li>
    </ul>

    <p class="links">
  <a href="http://weibo.com/SuDoYc" target="_new"><i class="fa fa-weibo"></i></a>
  <a href="mailto:ychost@outlook.com" target="_new"><i class="fa fa-envelope-o"></i></a>
  <a href="tencent://message/?uin=292538649" target="_new"><i class="fa fa-qq"></i></a>
  <a href="https://github.com/ychost" target="_new"><i class="fa fa-github-alt"></i></a>
  <!--a href="/feed.xml" target="_new"><i class="fa fa-rss"></i></a-->
</p>

  </div>
</nav>
<div class="menu-button" href="#menu"><i class="fa fa-bars"></i></div>


    <div class="page-content">
      <div class="wrap">
      <head>
  <link rel="stylesheet" href="/css/markdown-themes/markdown.css">
  <link rel="stylesheet" href="/css/markdown-themes/node-dark.css">
</head>

<div class="container-fluid single">
  <div class="row">

<div itemscope itemtype="http://schema.org/Article" class="col-md-12 article">      
      <div class="thumb">
        <i class="fa fa-weibo fa-3x"></i>
      </div>
      

      <h1 style="font-size:45px;font-weight:900"class="header"   itemprop="name">C++ Primer 学习笔记</h1>

      <div class="author" style="font-size:24px">
        <span><i style="font-style:normal;">

          作者：
          <span itemprop="author">
            <span itemprop="author" itemscope itemtype="http://schema.org/Person">
              <span itemprop="name" class="author-post-name";><strong>
                
                    ychost
                
              </strong></span>
            </span>
          </span>


         &nbsp;  时间：<span itemprop="datePublished" content="2014-08-28">11/12/2015</span>
        </i>
        
           &nbsp;<span style="font-style:oblique">------ 转载请注明出处</span>
        
      </span>
      </div>

      <div class="markdown  node-dark " >
        <span itemprop="articleBody"><p><center><h1>C++Primer(第四版笔记)</h1></center>
<small>注：只是为了测试博客用，此文章为自己当初随意记录的txt文件，所以未排版。</small></p>

<hr>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="err">第二章</span> <span class="err">变量和基本类型</span>
<span class="err">编译时间：</span><span class="mi">2014</span><span class="o">-</span><span class="mi">3</span><span class="o">-</span><span class="mi">19</span>
<span class="err">完成时间：</span><span class="mi">2014</span><span class="o">-</span><span class="mi">3</span><span class="o">-</span><span class="mi">19</span>

<span class="mf">1.</span>  <span class="err">字节长度：</span>    <span class="n">size</span> <span class="n">of</span> <span class="kt">char</span><span class="o">:</span><span class="mi">1</span> <span class="c1">//64位机器 单位字节 byte
</span><span class="err">　　</span><span class="n">size</span> <span class="n">of</span> <span class="kt">int</span><span class="o">:</span><span class="mi">4</span>
<span class="err">　　</span><span class="n">size</span> <span class="n">of</span> <span class="kt">long</span> <span class="o">:</span><span class="mi">4</span>
<span class="err">　　</span><span class="n">size</span> <span class="n">of</span> <span class="kt">float</span> <span class="o">:</span><span class="mi">4</span>
<span class="err">　　</span><span class="n">size</span> <span class="n">of</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">:</span><span class="mi">8</span>
<span class="err">　　</span><span class="n">size</span> <span class="n">of</span> <span class="kt">double</span><span class="o">:</span><span class="mi">8</span>
<span class="err">　　</span><span class="n">size</span> <span class="n">of</span> <span class="kt">long</span> <span class="kt">double</span><span class="o">:</span><span class="mi">12</span>
<span class="n">size</span> <span class="n">of</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">:</span><span class="mi">8</span>

<span class="mf">2.</span><span class="err">’</span><span class="n">a</span><span class="err">’输出</span><span class="n">a</span>        <span class="n">L</span><span class="err">’</span><span class="n">a</span><span class="err">’输出</span> <span class="n">ASCII</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">=</span><span class="mi">97</span>
<span class="mf">3.</span><span class="err">初始化分为</span> <span class="err">复制初始化”</span><span class="o">=</span><span class="err">”和直接初始化”</span><span class="p">(</span><span class="err">初始化值</span><span class="p">)</span><span class="err">”</span><span class="c1">//建议用直接初始化
</span><span class="mf">4.</span><span class="k">extern</span> <span class="err">变量若初始化了</span> <span class="err">则这里的</span><span class="k">extern</span> <span class="err">相当于定义</span>
<span class="mf">5.</span><span class="k">const</span> <span class="err">变量且必须初始化</span> <span class="err">不能被其他文件访问</span> <span class="err">若想被其他文件访问则必须加</span> <span class="n">extrern</span>
<span class="err">　　例如：</span>
<span class="err">　　</span><span class="c1">//file_1.cpp
</span><span class="err">　　</span><span class="k">extern</span>  <span class="k">const</span> <span class="kt">int</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
<span class="err">　　</span><span class="c1">//file_2.cpp
</span><span class="err">　　</span><span class="n">Extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">buf</span> <span class="n">size</span> <span class="p">;</span>

<span class="mf">6.</span><span class="err">引用</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span> <span class="err">就是对象的另一个名字</span> <span class="err">变量名前添加”</span><span class="o">&amp;</span><span class="err">”</span>    <span class="err">关联到其他类型</span>
    <span class="err">必须与该引用同类型的对象初始化所有的操作都是作用在绑定的对象上的</span>   <span class="err">不能绑定其他对象</span>
<span class="err">　　</span><span class="n">eg</span><span class="o">:</span>

<span class="o">&lt;</span><span class="n">figure</span> <span class="k">class</span><span class="err">="</span><span class="nc">highlight</span><span class="s">"&gt;&lt;pre&gt;&lt;code class="</span><span class="n">language</span><span class="o">-</span><span class="n">c</span><span class="o">--</span><span class="s">" data-lang="</span><span class="n">c</span><span class="o">++</span><span class="s">"&gt;&lt;span class="</span><span class="n">err</span><span class="s">"&gt;　　&lt;/span&gt;&lt;span class="</span><span class="n">kt</span><span class="s">"&gt;int&lt;/span&gt; &lt;span class="</span><span class="n">n</span><span class="s">"&gt;i&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;=&lt;/span&gt;&lt;span class="</span><span class="n">mi</span><span class="s">"&gt;1024&lt;/span&gt;&lt;span class="</span><span class="n">p</span><span class="s">"&gt;,&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;&amp;amp;&lt;/span&gt;&lt;span class="</span><span class="n">n</span><span class="s">"&gt;i2&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;=&lt;/span&gt;&lt;span class="</span><span class="n">n</span><span class="s">"&gt;i&lt;/span&gt;&lt;span class="</span><span class="n">p</span><span class="s">"&gt;;&lt;/span&gt;</span><span class="err">
</span><span class="s">&lt;span class="</span><span class="n">err</span><span class="s">"&gt;　　&lt;/span&gt;&lt;span class="</span><span class="n">c1</span><span class="s">"&gt;//const reference:const reference to a const object</span><span class="err">
</span><span class="s">&lt;/span&gt;&lt;span class="</span><span class="n">err</span><span class="s">"&gt;　　&lt;/span&gt;&lt;span class="</span><span class="n">k</span><span class="s">"&gt;const&lt;/span&gt; &lt;span class="</span><span class="n">kt</span><span class="s">"&gt;int&lt;/span&gt; &lt;span class="</span><span class="n">n</span><span class="s">"&gt;ival&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;=&lt;/span&gt;&lt;span class="</span><span class="n">mi</span><span class="s">"&gt;1024&lt;/span&gt;&lt;span class="</span><span class="n">p</span><span class="s">"&gt;;&lt;/span&gt;</span><span class="err">
</span><span class="s">&lt;span class="</span><span class="n">err</span><span class="s">"&gt;　　&lt;/span&gt;&lt;span class="</span><span class="n">k</span><span class="s">"&gt;const&lt;/span&gt; &lt;span class="</span><span class="n">kt</span><span class="s">"&gt;int&lt;/span&gt; &lt;span class="</span><span class="n">o</span><span class="s">"&gt;&amp;amp;&lt;/span&gt;&lt;span class="</span><span class="n">n</span><span class="s">"&gt;refVal&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;=&lt;/span&gt;&lt;span class="</span><span class="n">n</span><span class="s">"&gt;ival&lt;/span&gt;&lt;span class="</span><span class="n">p</span><span class="s">"&gt;;&lt;/span&gt;&lt;span class="</span><span class="n">c1</span><span class="s">"&gt;//ok, but can’t change refVal and ival</span><span class="err">
</span><span class="s">&lt;/span&gt;&lt;span class="</span><span class="n">err</span><span class="s">"&gt;　　&lt;/span&gt;&lt;span class="</span><span class="n">kt</span><span class="s">"&gt;int&lt;/span&gt; &lt;span class="</span><span class="n">o</span><span class="s">"&gt;&amp;amp;&lt;/span&gt;&lt;span class="</span><span class="n">n</span><span class="s">"&gt;ref2&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;=&lt;/span&gt;&lt;span class="</span><span class="n">n</span><span class="s">"&gt;ival&lt;/span&gt;&lt;span class="</span><span class="n">p</span><span class="s">"&gt;;&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;//&lt;/span&gt;&lt;span class="</span><span class="n">n</span><span class="s">"&gt;erro&lt;/span&gt;&lt;span class="</span><span class="n">o</span><span class="s">"&gt;:&lt;/span&gt; &lt;span class="</span><span class="n">n</span><span class="s">"&gt;nonconst&lt;/span&gt; &lt;span class="</span><span class="n">n</span><span class="s">"&gt;reference&lt;/span&gt; &lt;span class="</span><span class="n">n</span><span class="s">"&gt;to&lt;/span&gt; &lt;span class="</span><span class="n">n</span><span class="s">"&gt;a&lt;/span&gt; &lt;span class="</span><span class="n">k</span><span class="s">"&gt;const&lt;/span&gt; &lt;span class="</span><span class="n">n</span><span class="s">"&gt;object&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</span><span class="err">

</span><span class="s">　　非const 引用只能绑定到与该应用同类型的对象</span><span class="err">
</span><span class="s">　　const引用则可以绑定到不同但相关的类型的对象或绑定右值</span><span class="err">
</span><span class="s"> 若const引用指向非const对象就不能通过const间接修改对象</span><span class="err">
</span><span class="s"> 但可以通过非const对象直修改</span><span class="err">
</span><span class="s">　　eg:  </span><span class="err">
</span><span class="s">　　int i=42;</span><span class="err">
</span><span class="s">　　int &amp;x=42;</span><span class="err">
</span><span class="s">　　//legal for const reference only</span><span class="err">
</span><span class="s">　　const int &amp;r=40;//r==42   x=r;//将40赋值给i</span><span class="err">
</span><span class="s">　　const int &amp;r2=r+i;</span><span class="err">
</span><span class="s">7.typedef double wages;</span><span class="err">
</span><span class="s">　　typedef wages salary;//indirect synonym for double</span><span class="err">
</span><span class="s">8.枚举(enumeration)</span><span class="err">
</span><span class="s">　　eg:</span><span class="err">
</span><span class="s">　　//input is 0 ,output is 1, and append is 2</span><span class="err">
</span><span class="s">　　enum open_modes{input,output,append};</span><span class="err">
</span><span class="s">　　默认地后一个枚举成员的值比前一个大一</span><span class="err">
</span><span class="s">　　//p1 is 2,p2 is 3, p3 is 3,p4 is 4</span><span class="err">
</span><span class="s">　　enum points{p1=2,p2,p3=3,p4};  //用来初始化枚举成员的值必须是一个常量表达式</span><span class="err">
</span><span class="s"> //枚举对象的初始化和赋值必须是枚举对象或同一枚举对象的其他对象</span><span class="err">
</span><span class="s"> p p1d=p3    //ok</span><span class="err">
</span><span class="s"> p p1x=3;    //erro : p1x initialized with int</span><span class="err">
</span><span class="s">9.类类型(class)</span><span class="err">
</span><span class="s"> 类中public 部分定义的成员在程序的任何部分都可以访问。通常在public 部</span><span class="err">
</span><span class="s">分放置操作，以便程序中的其他部分可以执行这些操作。</span><span class="err">
</span><span class="s">类中private 部分定义的成员只能被作为类的组成部分的代码（以及该类的友</span><span class="err">
</span><span class="s">元）访问。通常在private 部分放置数据，以对对象的内部数据进行隐藏。</span><span class="err">
</span><span class="s">     (struct)</span><span class="err">
</span><span class="s"> 成员默认都是public class 成员默认为private</span><span class="err">
</span><span class="s">10.头文件一般包括 类的定义、extern的声明和函数的声明(头文件用于声明而不是定义)</span><span class="err">
</span><span class="s"> 三个例外：</span><span class="err">
</span><span class="s">     可以定义类 值在编译时就知道的const对象(常量初始化的const对象)和inline对象</span><span class="err">
</span><span class="s">小结：</span><span class="err">
</span><span class="s">---------------------</span><span class="err">
</span><span class="s">     类型是C++程序设计的基础</span><span class="err">
</span><span class="s">     每种类型都定义了其储存空间要求和可以在该类型的所有对象上执行的操作。</span><span class="err">
</span><span class="s">     C++提供了一组基本内置类型，如 int、char、等。这些类型与它们所在机</span><span class="err">
</span><span class="s">     器硬件   上的表示方式紧密相关。</span><span class="err">
</span><span class="s">     类型可以为const或非const；const对象必须要初始化且其值不能修改。</span><span class="err">
</span><span class="s">     另外，我们还可以订衣服和类型，如引用。引用为一个对象提供了另一个名字。</span><span class="err">
</span><span class="s">     复合类型是其他类型定义的类型。</span><span class="err">
</span><span class="s">     C++语言支持通过定义类来自定义类型。标准库实用类设施来提供一组高级的抽象概念，</span><span class="err">
</span><span class="s">     如IO和string类型</span><span class="err">
</span><span class="s">     C++是一种静态类型语言：变量和函数在使用前必须先声明。变量可少声明多次但是</span><span class="err">
</span><span class="s">     只能定义一次。定义变量时就是进行初始化几乎总是个好主意。</span><span class="err">
</span><span class="s">-----------------------</span><span class="err">


</span><span class="s">/*--------------------------------------------------------------------------</span><span class="err">
</span><span class="s">第三章 标准库类型</span><span class="err">

</span><span class="s">编译时间：2014-3-19</span><span class="err">
</span><span class="s">完成时间：2014-3-22</span><span class="err">
</span><span class="s">----------------------------------------------------------------------------*/</span><span class="err">
</span><span class="s">1.string的几种初始化 #include &lt;string&gt;; or using std::string;</span><span class="err">
</span><span class="s"> eg:</span><span class="err">
</span><span class="s">     string s1;//s1 为空字符串</span><span class="err">
</span><span class="s">     string s2(s1);//s2初始化为s1的副本</span><span class="err">
</span><span class="s">     string s3("</span><span class="n">value</span><span class="s">");//s3为字符串面值副本</span><span class="err">
</span><span class="s">     string s4(n,'c')//s4初始化为字符'c'的n个副本</span><span class="err">
</span><span class="s"> string //对象忽略开头空白 一空白结尾</span><span class="err">
</span><span class="s"> getline(cin,string) //以换行符结束 不忽略空白 以换行符结束</span><span class="err">
</span><span class="s"> string 对象的属性</span><span class="err">
</span><span class="s"> s.size()//返回s中字符的个数 注意返回值是个string::size_type类型 不要把他当作int</span><span class="err">
</span><span class="s"> s.empty()//检测是否为空字串</span><span class="err">
</span><span class="s"> s[n]//返回s中位置为n的字符，n is index s.(s.size()-1)返回s的最后一个字符</span><span class="err">
</span><span class="s"> string 对象的相加的+操作符的左右数必须至少有一个是string类型的</span><span class="err">
</span><span class="s"> eg:</span><span class="err">
</span><span class="s">     string s1="</span><span class="n">hello</span><span class="s">";</span><span class="err">
</span><span class="s">     string s2="</span><span class="n">world</span><span class="s">";</span><span class="err">
</span><span class="s">     string s3=s1+"</span><span class="p">,</span><span class="s">";//ok</span><span class="err">
</span><span class="s">     string s4="</span><span class="n">hello</span><span class="s">"+"</span><span class="p">,</span><span class="s">";//error: no string operand</span><span class="err">
</span><span class="s">     string s5=s1+"</span><span class="p">,</span><span class="s">"+"</span><span class="n">world</span><span class="s">"//ok</span><span class="err">
</span><span class="s">     string s6="</span><span class="n">hello</span><span class="s">"+"</span><span class="p">,</span><span class="s">"+s2;//erro: can't add string literals</span><span class="err">
</span><span class="s">2.头文件cctype</span><span class="err">
</span><span class="s">     从c继承过来的</span><span class="err">
</span><span class="s">3.vector（容器）--仅能对已存在的元素进行下标操作</span><span class="err">
</span><span class="s"> vector&lt;T&gt; v1;//v1为空</span><span class="err">
</span><span class="s"> vector&lt;T&gt; v2(v1);//v2是v1的一个副本 v2的元素和v1必须保持一致</span><span class="err">
</span><span class="s"> vector&lt;T&gt; v3(n,i);//v3包含n个i元素</span><span class="err">
</span><span class="s"> vector&lt;T&gt; v4(n);//v4初始化的元素的N个副本</span><span class="err">
</span><span class="s"> 属性</span><span class="err">
</span><span class="s">     v.empty();</span><span class="err">
</span><span class="s">     v.size();//返回vectir::size_type类型</span><span class="err">
</span><span class="s">     v.push_back(t);//在v的末尾加一个值为t的元素 动态增加元素只能靠它</span><span class="err">

</span><span class="s">4.iterator(迭代器)</span><span class="err">
</span><span class="s"> begin();//返回容器的第一个元素</span><span class="err">
</span><span class="s"> end();//返回容器末端的下一个元素---超出末端迭代器</span><span class="err">
</span><span class="s"> //若ivec为空则 begin()和end()返回的迭代器相同</span><span class="err">
</span><span class="s"> eg:</span><span class="err">
</span><span class="s">     vector&lt;int&gt;::iterater iter=ivec.begin();//iter指向ivec[0]</span><span class="err">
</span><span class="s"> *iter//迭代器解引操作符 访问迭代器指向的元素</span><span class="err">
</span><span class="s"> 两个迭代器指向同一元素则相等</span><span class="err">
</span><span class="s">5.const_iterator(只读迭代器)</span><span class="err">
</span><span class="s"> 注意区分：</span><span class="err">
</span><span class="s">     //不能改变所指元素的值</span><span class="err">
</span><span class="s">     vector&lt;int&gt;::const_iterator x=ivec.begin();</span><span class="err">
</span><span class="s">         x++;//ok</span><span class="err">
</span><span class="s">         *x=1;//error: *x is const</span><span class="err">
</span><span class="s">     //不能改变x本身的值 但能修改所指对象的值 const对象必须初始化</span><span class="err">
</span><span class="s">     const vector&lt;int&gt;:: iterator y=ivec.brgin();</span><span class="err">
</span><span class="s">         y++;//erro: can't change the value of y</span><span class="err">
</span><span class="s">         *y=1;//ok</span><span class="err">
</span><span class="s">/*---------------------</span><span class="err">
</span><span class="s"> const 迭代器是迭代器常量，该迭代器本身的值不能修改，即该迭代器在定义时</span><span class="err">
</span><span class="s"> 需要初始化，而且初始化之后，不能再指向其他元素。若需要指向固定元素的</span><span class="err">
</span><span class="s"> 迭代器，则可以使用const 迭代器。</span><span class="err">
</span><span class="s"> const_iterator 是一种迭代器类型，对这种类型的迭代器解引用会得到一个指</span><span class="err">
</span><span class="s"> 向const 对象的引用，即通过这种迭代器访问到的对象是常量。该对象不能修</span><span class="err">
</span><span class="s"> 改，因此，const_iterator 类型只能用于读取容器内的元素，不能修改元素的</span><span class="err">
</span><span class="s"> 值。若只需遍历容器中的元素而无需修改它们，则可以使用const_iterator。</span><span class="err">
</span><span class="s">---------------------*/</span><span class="err">
</span><span class="s"> 代数操作;</span><span class="err">
</span><span class="s">     //返回值是一个新的迭代器</span><span class="err">
</span><span class="s">     iter+n;</span><span class="err">
</span><span class="s">     iter-n;</span><span class="err">
</span><span class="s">     //返回值类型是 difference_type(signed)</span><span class="err">
</span><span class="s">     iter1-iter2</span><span class="err">
</span><span class="s">     iter1+iter2;</span><span class="err">
</span><span class="s">         ivec.begin()+ivec.end();//erro:将两个迭代器相加的操作是未定义的，因此用这种方法计算mid 会出现编译错误。</span><span class="err">
</span><span class="s">注意：</span><span class="err">
</span><span class="s"> 任何改变vector长度的操作都会使已存的迭代器失效</span><span class="err">
</span><span class="s">6.bitset 初始化是十进制或16进制</span><span class="err">
</span><span class="s"> bitset&lt;32&gt; bitvec//32 bits ,all zero</span><span class="err">
</span><span class="s"> bitset&lt;n&gt; b;  //b有n位，每位是0</span><span class="err">
</span><span class="s"> bitset&lt;n&gt; b(u);   //b是unsigned long型u的一个副本</span><span class="err">
</span><span class="s"> bitset&lt;n&gt; b(s);   //b是string 对象s中含有位串的副本</span><span class="err">
</span><span class="s"> bitset&lt;n&gt; b(s,pos,n);//b是s从位置pos开始的n个位 的副本</span><span class="err">

</span><span class="s"> 用unsigned 初始化bitset对象</span><span class="err">
</span><span class="s">     //32位机器十六进制0XFFFF 表示16个1和16个0</span><span class="err">
</span><span class="s">     //bitvecl is smaller than the initialized</span><span class="err">
</span><span class="s">     bitset&lt;16&gt; bitvec1(0xffff);//11111111 11111111</span><span class="err">
</span><span class="s">     //bitvec2 is same size as initialized</span><span class="err">
</span><span class="s">     bitset&lt;32&gt; bitvec2(0xffff)//bits 0..15 are set to 1;16...31 are 0xffff</span><span class="err">
</span><span class="s">     //on a 32-bit machine,bits 0 to 31 initialized from 0xffff</span><span class="err">
</span><span class="s">     bitset&lt;128&gt; bitvec3(0xffff);//bits 32 through 127 initialized to zero</span><span class="err">

</span><span class="s"> 用string对象初始化bitset对象    //bitset和string是反转的</span><span class="err">
</span><span class="s">     //string对象的最右字符(下标最大的那个)用来初始化bitset的低阶位(即下标为0)</span><span class="err">
</span><span class="s">     string s("</span><span class="mi">1100</span><span class="s">");</span><span class="err">
</span><span class="s">     bitset&lt;4&gt; bitvec4(s);//0011</span><span class="err">

</span><span class="s"> bitset对象的操作//P90</span><span class="err">
</span><span class="s">     ///include &lt;cstddef.h&gt;</span><span class="err">
</span><span class="s">     bitvec.count()//二进制中1的个数 返回类型size_t</span><span class="err">

</span><span class="s">     bitvec.to_ulong//转换成ulong(十进制)</span><span class="err">
</span><span class="s">     b.filp(pos)//某一位取反</span><span class="err">
</span><span class="s">         ...</span><span class="err">
</span><span class="s">小结：</span><span class="err">
</span><span class="s">-------------------------</span><span class="err">
</span><span class="s">     C++标准库定义看几种更高级的抽象数据类型，包括string和vector类型。string类型</span><span class="err">
</span><span class="s">     提供了变长的字符串，而vector类型则可用于管理同一类型的对象集合。</span><span class="err">
</span><span class="s">     迭代器实现了对容器中对象的间接访问。迭代器课一用于访问和遍历string类型</span><span class="err">
</span><span class="s">     和vector类型的元素。</span><span class="err">

</span><span class="s">-------------------------</span><span class="err">

</span><span class="s">/*----------------------------------------------------</span><span class="err">
</span><span class="s">第四章    数组和指针</span><span class="err">

</span><span class="s">编译时间：2014-3-22</span><span class="err">
</span><span class="s">完成时间：2014-3-27</span><span class="err">
</span><span class="s">-----------------------------------------------------*/</span><span class="err">
</span><span class="s">1.相关规定</span><span class="err">
</span><span class="s"> 数组维数必须是大于等于1的常量表达式(字面常量，枚举常量，初始化整形const对象)</span><span class="err">
</span><span class="s"> 函数体内定义数组无初始化</span><span class="err">
</span><span class="s"> 体外定义数组初始化0</span><span class="err">
</span><span class="s"> 类类型默认构造函数初始化，若无默认构造函数则必须显示初始化</span><span class="err">
</span><span class="s"> 显示初始化没必要指定维数</span><span class="err">
</span><span class="s">     eg:</span><span class="err">
</span><span class="s">         int ia[]={0,1,2);</span><span class="err">
</span><span class="s"> 字符串初始化</span><span class="err">
</span><span class="s">     eg:</span><span class="err">
</span><span class="s">     const char ca3[6]="</span><span class="n">Daniel</span><span class="s">";//erro: Daniel is 7 element include '</span><span class="se">\0</span><span class="s">'</span><span class="err">
</span><span class="s"> 不允许数组直接复制和赋值</span><span class="err">
</span><span class="s">     int ia[]={0,2,3};//ok</span><span class="err">
</span><span class="s">     int ia2[](ia);//erro: cannot initialize one array with another</span><span class="err">
</span><span class="s">     int ia3[];</span><span class="err">
</span><span class="s">     ia3=ia;//erro: cannot asssign one array to another</span><span class="err">
</span><span class="s">2.与vector的比较</span><span class="err">
</span><span class="s"> 与vector 类型相比，数组具有如下缺点：</span><span class="err">
</span><span class="s"> 数组的长度是固定的，而且数组不提供获取其容量大小的size 操作，</span><span class="err">
</span><span class="s"> 也不提供自动添加元素的push_back 操作。因此，程序员无法在程序</span><span class="err">
</span><span class="s"> 运行时知道一个给定数组的长度，而且如果需要更改数组的长度，程</span><span class="err">
</span><span class="s"> 序员只能创建一个更大的新数组，然后把原数组的所有元素复制到新</span><span class="err">
</span><span class="s"> 数组的存储空间中去。与使用vector 类型的程序相比，使用内置数组</span><span class="err">
</span><span class="s"> 的程序更容易出错且难以调试</span><span class="err">
</span><span class="s">3.指针</span><span class="err">
</span><span class="s"> 一个有效的指针必然是一下三种状态之一</span><span class="err">
</span><span class="s">     保存一个特定对象的地址</span><span class="err">
</span><span class="s">         指向某个对象后面的另一个对象</span><span class="err">
</span><span class="s">             零值，若是0值表明他不指向任何对象</span><span class="err">
</span><span class="s"> 注意：避免使用为初始化的指针              </span><span class="err">
</span><span class="s">             /*</span><span class="err">
</span><span class="s">             无法确定某指针是否指向一个有效对象。因为，在C++语言中，无法检测指</span><span class="err">
</span><span class="s">             针是否未被初始化，也无法区分一个地址是有效地址，还是由指针所分配的存</span><span class="err">
</span><span class="s">             储空间中存放的不确定值的二进制位形成的地址。</span><span class="err">
</span><span class="s">         */</span><span class="err">
</span><span class="s">     把int型变量赋值给指针式非法的。</span><span class="err">
</span><span class="s">         int ival;</span><span class="err">
</span><span class="s">         int zero=0;</span><span class="err">
</span><span class="s">         const int c_ival=0;</span><span class="err">
</span><span class="s">         int *pi=ival;//erro: pi intialized from int value of ival</span><span class="err">
</span><span class="s">         pi=zero//erro: pi assigned int value zero</span><span class="err">
</span><span class="s">         pi=c_ival;//ok</span><span class="err">
</span><span class="s">         pi=0;//ok</span><span class="err">
</span><span class="s">     指针只能初始化或赋值为同类型的变量地址或另一指针</span><span class="err">

</span><span class="s">     double obj=3.14;</span><span class="err">
</span><span class="s">     double *pd=&amp;obj;</span><span class="err">
</span><span class="s">     //ok void* can hold the address value of any data pointer typedef</span><span class="err">
</span><span class="s">     void *pv=&amp;obj;//obj can be an object of any typedef</span><span class="err">
</span><span class="s">     pv=pd;//pd can be a pointer to any typedef</span><span class="err">
</span><span class="s">         void*表明指针与一地址相关，但不清楚储存在地址上的对象的类型</span><span class="err">
</span><span class="s"> 指针和引用(refrence)的比较</span><span class="err">
</span><span class="s">     /*----------------------</span><span class="err">
</span><span class="s">     使用引用（reference）和指针（pointer）都可间接访问另一个值，但它们之</span><span class="err">
</span><span class="s">     间存在两个重要区别：(1)引用总是指向某个确定对象（事实上，引用就是该对</span><span class="err">
</span><span class="s">     象的别名），定义引用时没有进行初始化会出现编译错误；(2) 赋值行为上存</span><span class="err">
</span><span class="s">     在差异：给引用赋值修改的是该引用所关联的对象的值，而不是使该引用与另</span><span class="err">
</span><span class="s">     一个对象关联。引用一经初始化，就始终指向同一个特定对象。给指针赋值修</span><span class="err">
</span><span class="s">     改的是指针对象本身，也就是使该指针指向另一对象，指针在不同时刻可指向</span><span class="err">
</span><span class="s">     不同的对象（只要保证类型匹配）。</span><span class="err">
</span><span class="s">     -------------------------*/</span><span class="err">
</span><span class="s"> 指针指向指针</span><span class="err">
</span><span class="s">     int ival=1024;</span><span class="err">
</span><span class="s">     int *pi=&amp;ival;</span><span class="err">
</span><span class="s">     int **ppi=&amp;pi;</span><span class="err">
</span><span class="s">     双解引ppi ---**ppi</span><span class="err">
</span><span class="s"> 指针访问数组元素</span><span class="err">
</span><span class="s">     int ia[]={0,2,4,6,8};</span><span class="err">
</span><span class="s">     int *ip=ia; //ip points to ia[0]</span><span class="err">
</span><span class="s">          ip=&amp;ia[4]; //ip points last element in ia</span><span class="err">
</span><span class="s"> 指针的算术操作</span><span class="err">
</span><span class="s">     ip=ia;      //ok: ip point tp ia[0]</span><span class="err">
</span><span class="s">     int *ip2=ip+4;//ok: ip2 points to ia[4],the last element in ia</span><span class="err">
</span><span class="s">     ptrdiff_t n=ip2-ip;//ok:distance between the pointers</span><span class="err">
</span><span class="s">     //注：ptrdiff包含于 cstddef头文件 signed类型</span><span class="err">
</span><span class="s">     在指针加一个整数值其结果仍然是一个指针</span><span class="err">
</span><span class="s">     int last =*(ia +4);</span><span class="err">
</span><span class="s"> 下标和指针</span><span class="err">
</span><span class="s">     使用下标访问数组时，实际上是用下标访问指针</span><span class="err">
</span><span class="s">         int ia[]={0,2,4,6,8};</span><span class="err">
</span><span class="s">         int i=ia[0];//i point to the first elment in ia</span><span class="err">
</span><span class="s">         int *p=&amp;ia[2];</span><span class="err">
</span><span class="s">         int j=p[1];//ok:p[1] eq to *(p+1),  p[1] is the same element as ia[3]</span><span class="err">
</span><span class="s">         int k=p[-2];//ok:p[-2] is the same element as ia[0]</span><span class="err">
</span><span class="s">     计算数组的超出末端指针</span><span class="err">
</span><span class="s">         const size_t arr_size=5;</span><span class="err">
</span><span class="s">         int arr[arr_size]={1,2,3,4,5};</span><span class="err">
</span><span class="s">         int *p=arr;</span><span class="err">
</span><span class="s">         int *p2=p+arr_size;//ok point one past end of arr</span><span class="err">
</span><span class="s">                         //use caution --do not dereference 不允许解引</span><span class="err">
</span><span class="s"> 输出数组</span><span class="err">
</span><span class="s">     const size_t arr_size=5;</span><span class="err">
</span><span class="s">     int int_arr[arr_size]={1,2,3,4,5};</span><span class="err">
</span><span class="s">     for(int *pi=int_arr,*pend=int_arr+arr_size;pi!=pend;pi++)</span><span class="err">
</span><span class="s">     {</span><span class="err">

</span><span class="s">         cout&lt;&lt;*pi;</span><span class="err">
</span><span class="s">             cout&lt;&lt;"</span>   <span class="s">"&lt;&lt;pi[2]&lt;&lt;endl;</span><span class="err">
</span><span class="s">     }</span><span class="err">
</span><span class="s">4.指针和const限定符</span><span class="err">
</span><span class="s"> 指向const对象的指针//“自以为指向const的指针”</span><span class="err">
</span><span class="s">     --不能保证指向const的指针所指对象的值一定不可修该</span><span class="err">
</span><span class="s">     --因为指向const对象的指针可以指向非const对象</span><span class="err">
</span><span class="s">     //cptr 指向的对象是cnst 但cptr不是const</span><span class="err">
</span><span class="s">     const double *cptr;//cptr may point to a double that is const</span><span class="err">
</span><span class="s">     --不能使用非const对象的指针或者void指针指向const对象</span><span class="err">
</span><span class="s">     --允许把非const对象地址赋值给指向const对象的指针</span><span class="err">
</span><span class="s"> const指针</span><span class="err">
</span><span class="s">     int errNum=0;</span><span class="err">
</span><span class="s">     int *const currErr=&amp;errNum;//currErr is a constant pointer</span><span class="err">
</span><span class="s">     --const指针必须初始化</span><span class="err">
</span><span class="s"> 指向const对象的const指针</span><span class="err">
</span><span class="s">     const double pi=3.14159;</span><span class="err">
</span><span class="s">     //pi_ptr is const and points to a const object</span><span class="err">
</span><span class="s">     const double *const pi_ttr=&amp;pi;</span><span class="err">
</span><span class="s">5.指针和typedef</span><span class="err">
</span><span class="s"> typedef string *pstring;</span><span class="err">
</span><span class="s"> const pstring cstr;</span><span class="err">
</span><span class="s"> //cstr is a const pointer to string</span><span class="err">
</span><span class="s"> string *const cstr//eq to const pstring cstr</span><span class="err">
</span><span class="s"> --声明const pstring 时，const修饰的是pstring 这是一个指针被修饰成const</span><span class="err">
</span><span class="s"> 理解复杂的const类型的声明</span><span class="err">
</span><span class="s">     //they're both string that const</span><span class="err">
</span><span class="s">     string const s1;</span><span class="err">
</span><span class="s">     const string s2;</span><span class="err">
</span><span class="s">     //they're all const pointers to string</span><span class="err">
</span><span class="s">     string s;</span><span class="err">
</span><span class="s">     typedef string *pstring;</span><span class="err">
</span><span class="s">     const pstring cstr1;</span><span class="err">
</span><span class="s">     pstring const cstr2;</span><span class="err">
</span><span class="s">     string *const cstr3;</span><span class="err">
</span><span class="s">6.C风格字符串   //#include&lt;cstring&gt;</span><span class="err">
</span><span class="s"> 字符串以null结束</span><span class="err">
</span><span class="s"> char*类型的指针用来操作c风格字符串</span><span class="err">
</span><span class="s">     const char *cp="</span> <span class="n">some</span> <span class="n">value</span> <span class="s">";</span><span class="err">
</span><span class="s">     while(*cp)</span><span class="err">
</span><span class="s">     {</span><span class="err">
</span><span class="s">         ++cp;</span><span class="err">
</span><span class="s">     }</span><span class="err">

</span><span class="s">     strlen(s)</span><span class="err">
</span><span class="s">     strcmp(s1,s2)//字符串是否相同 比较ASCII (s1&gt;s2)正 s1&lt;s2负 s1==s2 0</span><span class="err">
</span><span class="s">     strncat(s1,s2,n)</span><span class="err">
</span><span class="s">     strncpy(s1,s2,n)</span><span class="err">
</span><span class="s">     ...P114</span><span class="err">
</span><span class="s">     if(cp1&gt;cp2)//compares address,not the values pointed to</span><span class="err">
</span><span class="s"> 永远不要忘记字符串结束符null</span><span class="err">
</span><span class="s">     char ca[]={'c','+','+'};</span><span class="err">
</span><span class="s">     cout&lt;&lt;strlen(ca)&lt;&lt;endl;//disaster:ca isn't null-terminated</span><span class="err">
</span><span class="s"> 尽可能的使用标准库类型string</span><span class="err">
</span><span class="s">7.创建动态数组//new和delete 在自由储存区分配空间</span><span class="err">
</span><span class="s"> int *pia=new int[10];//arry of 10 uninitialized ints</span><span class="err">
</span><span class="s"> string *psa=new string[10];//arry of 10 empty strings</span><span class="err">
</span><span class="s"> int *pia=new int[10]();//arry of 10 initialized ints</span><span class="err">
</span><span class="s"> const 对象的动态数组</span><span class="err">
</span><span class="s">     //erro: uninitialized const array</span><span class="err">
</span><span class="s">     const int *pic_bad=new const [100];</span><span class="err">
</span><span class="s">     //ok:value-initialized const array</span><span class="err">
</span><span class="s">     const int *pic_ok =new const int[100]();</span><span class="err">
</span><span class="s">     //ok:array of 100 empty strings</span><span class="err">
</span><span class="s">     const string *pcs=new const string[100];</span><span class="err">
</span><span class="s">8.动态空间的释放</span><span class="err">
</span><span class="s"> delete [] pia;</span><span class="err">
</span><span class="s">9.动态数组的使用</span><span class="err">
</span><span class="s"> c_str() 把string 对象变成C风格字符串</span><span class="err">
</span><span class="s"> 用strlen(str1)+1 定义其长度</span><span class="err">

</span><span class="s"> eg：</span><span class="err">
</span><span class="s"> ------------------</span><span class="err">
</span><span class="s">     #include &lt;iostream&gt;</span><span class="err">
</span><span class="s">     #include &lt;cstring&gt;</span><span class="err">
</span><span class="s">     using namespace std;</span><span class="err">

</span><span class="s">     int main()</span><span class="err">
</span><span class="s">     {</span><span class="err">
</span><span class="s">         string s_in;</span><span class="err">
</span><span class="s">         cout&lt;&lt;"</span><span class="n">Enter</span> <span class="n">characters</span><span class="s">"&lt;&lt;endl;</span><span class="err">
</span><span class="s">         getline(cin,s_in);</span><span class="err">
</span><span class="s">         char *psc=new char[strlen(s_in.c_str())+1];</span><span class="err">

</span><span class="s">         strcpy(psc,s_in.c_str());//c_style</span><span class="err">

</span><span class="s">         cout&lt;&lt;"</span><span class="n">The</span> <span class="n">characters</span> <span class="n">that</span> <span class="n">you</span> <span class="n">input</span> <span class="n">justnow</span> <span class="n">is</span><span class="o">:</span> <span class="s">"&lt;&lt;endl;</span><span class="err">
</span><span class="s">         for(size_t i=0;i&lt;strlen(s_in.c_str())+1;i++)</span><span class="err">
</span><span class="s">         {</span><span class="err">
</span><span class="s">             cout&lt;&lt;psc[i];</span><span class="err">
</span><span class="s">         }</span><span class="err">
</span><span class="s">         delete[] psc;</span><span class="err">

</span><span class="s">         return 0;</span><span class="err">
</span><span class="s">     }</span><span class="err">
</span><span class="s">     -----------------</span><span class="err">
</span><span class="s"> 数组初始化vector</span><span class="err">
</span><span class="s">     int arr_int[]={0,1,2,3,4};</span><span class="err">
</span><span class="s">     //arr_int[0],arr_int[1]...arr_int[4])</span><span class="err">
</span><span class="s">     //首地址，最后一个元素后的地址空间</span><span class="err">
</span><span class="s">     vector&lt;int&gt; ivec(arr_int,arr_int+5);</span><span class="err">
</span><span class="s">10.多维数组</span><span class="err">
</span><span class="s"> 数组的数组</span><span class="err">
</span><span class="s">     int ia[3][4];//3行4列</span><span class="err">
</span><span class="s"> 初始化</span><span class="err">
</span><span class="s">     int ia[2][3]={</span><span class="err">
</span><span class="s">             {0,1,2},</span><span class="err">
</span><span class="s">             {3,4,5},</span><span class="err">
</span><span class="s">             };</span><span class="err">
</span><span class="s"> 若表达式只提供了一个下标则结果获取的元素是该行下标索引的内层数组</span><span class="err">
</span><span class="s">     如 ia[1]表示了ia的最后一行</span><span class="err">
</span><span class="s"> 指针和多维数组</span><span class="err">
</span><span class="s">     int ia[3][4];</span><span class="err">
</span><span class="s">     //从内向外读 *ip 是int[4]类型--ip是一个致指向含有4个元素的指针</span><span class="err">
</span><span class="s">     int (*ip)[4]=ia;//ip points to an array of 4 ints</span><span class="err">
</span><span class="s">     ip=&amp;ia[2];//ia[2] is an array of 4 ints</span><span class="err">
</span><span class="s"> typedef简化指向多维数组的指针</span><span class="err">
</span><span class="s"> typedef int int_array[4];</span><span class="err">
</span><span class="s"> int_array *ip=ia;</span><span class="err">
</span><span class="s"> for(int_array *p=ia;p!=ia+3;++p1)//处理行 p是一个指向含有4个元素的指针</span><span class="err">
</span><span class="s">     for(int *q=*p;q!=*p+4;q++)//处理列   q指向p所指对象的第一个地址</span><span class="err">
</span><span class="s">         cout&lt;&lt;*q&lt;&lt;endl;</span><span class="err">
</span><span class="s">小结：</span><span class="err">
</span><span class="s">--------------------------</span><span class="err">
</span><span class="s">     迭代器和指针都能用于间接地访问所指向的对象。vector类型所包含的元素通过</span><span class="err">
</span><span class="s">     迭代器操纵，类似地，指针则用于访问数组元素。某些低级任务必须使用指针和</span><span class="err">
</span><span class="s">     数组，但是由于使用指针和数组容易出错而且难以调试，应尽量避免使用。一般</span><span class="err">
</span><span class="s">     而言，应优先使用标准库抽象类而少用语言内置的低级数组和指针。尤其是应该</span><span class="err">
</span><span class="s">     使用string类型取代c风格以空字符串结束的字符数组。现代c++程序不应该使用</span><span class="err">
</span><span class="s">     c风格字符串。</span><span class="err">

</span><span class="s">--------------------------</span><span class="err">
</span><span class="s">/*----------------------------------------------------</span><span class="err">
</span><span class="s">第四章 表达式</span><span class="err">

</span><span class="s">编译时间：2014-3-30</span><span class="err">
</span><span class="s">修改时间：2014-4-3</span><span class="err">
</span><span class="s">-----------------------------------------------------*/</span><span class="err">
</span><span class="s">1.算术操作</span><span class="err">
</span><span class="s"> 除法(/)和求模(%)</span><span class="err">
</span><span class="s">     如果两个操作数都为正数则求模和除法都是整数</span><span class="err">
</span><span class="s">     如果两个操作数都为负数除法为正，求模为负</span><span class="err">
</span><span class="s">     如果操作数一正一负除法是负，而求模取决于机器(我的是负),两个的机器都取决于机器</span><span class="err">
</span><span class="s">2.不能串联使用关系操作符</span><span class="err">
</span><span class="s"> //oops!this condition does not determine if the 3 values are unequal</span><span class="err">
</span><span class="s"> if(i&lt;j&lt;k)//这种写法只要k大于1，就为true。</span><span class="err">
</span><span class="s">3.移位操作不能是负数(因为不同环境的结果不一致)</span><span class="err">
</span><span class="s"> X&gt;&gt;4//right shift</span><span class="err">
</span><span class="s"> Y&lt;&lt;4//left shift</span><span class="err">
</span><span class="s"> 注意 逻辑与&amp;&amp; 逻辑或||</span><span class="err">
</span><span class="s">     位于&amp; 位或 |</span><span class="err">
</span><span class="s">4.bitset对象或整型值得使用</span><span class="err">
</span><span class="s"> bitset&lt;30&gt; bitset_quiz1;</span><span class="err">
</span><span class="s"> unsigned long init_quiz1=0;</span><span class="err">
</span><span class="s"> bitset_quiz1.set(27);//indicate student number 27 passed</span><span class="err">
</span><span class="s"> int_quiz1 |=1UL&lt;&lt;27;//indicate student number 27 passed</span><span class="err">

</span><span class="s"> bitset_quiz1.reset(27);</span><span class="err">
</span><span class="s"> int_quiz1 &amp;=~(1UL&lt;&lt;27);</span><span class="err">

</span><span class="s"> bool status;</span><span class="err">
</span><span class="s"> status = bitset_quiz1[27];</span><span class="err">
</span><span class="s"> status = int_quiz1 &amp; (1UL&lt;&lt;27);</span><span class="err">
</span><span class="s">5.IO操作符为左结合</span><span class="err">
</span><span class="s"> cout&lt;&lt;"</span><span class="n">hello</span><span class="s">"&lt;&lt;"</span> <span class="n">world</span><span class="o">!</span><span class="s">"&lt;&lt;endl;</span><span class="err">
</span><span class="s"> 移位操作符的优先级：其优先级比算术操作符低，但比关系操作符、赋值操作符和条件操作符的优先级高</span><span class="err">
</span><span class="s"> cout&lt;&lt;42+10;// ok</span><span class="err">
</span><span class="s"> cout&lt;&lt;(10&lt;42)//ok</span><span class="err">
</span><span class="s"> cout&lt;&lt;10&lt;42;//erro</span><span class="err">
</span><span class="s">6.赋值操作</span><span class="err">
</span><span class="s"> int ival,jval;</span><span class="err">
</span><span class="s"> ival=jval=1;</span><span class="err">

</span><span class="s"> int ival;int *pval;</span><span class="err">
</span><span class="s"> ival=pval;//erro</span><span class="err">
</span><span class="s">7.符合操作</span><span class="err">
</span><span class="s"> a op =b;</span><span class="err">
</span><span class="s">   op:+、-、*、/、%、&lt;&lt;、&gt;&gt;、^、|</span><span class="err">
</span><span class="s"> 自增、自减</span><span class="err">
</span><span class="s">     int i=0,j;</span><span class="err">
</span><span class="s">     j=++i;//j=1,i=1</span><span class="err">
</span><span class="s">     j=i++;//j=1,i=2</span><span class="err">
</span><span class="s">     /*-------------------</span><span class="err">
</span><span class="s">         前自增操作和后自增操作都使其操作数加1，二者的差别在于：前自增操作将修改后操作数</span><span class="err">
</span><span class="s">         的值作为表达式的结果值；而后自增操作将操作数原来的、未修改的值作为表达式的结果</span><span class="err">
</span><span class="s">         值。</span><span class="err">
</span><span class="s">     -------------------*/</span><span class="err">
</span><span class="s">     *iter++;//解引的是iter原值</span><span class="err">
</span><span class="s">         /*-----------------</span><span class="err">
</span><span class="s">             C++ 之名是Rick Mascitti 在1983 年夏天定名的（ 参见The C++ Programming</span><span class="err">
</span><span class="s">             Language(Special Edition) 1.4 节），C 说明它本质上是从C 语言演化而来的，“++”是C 语言</span><span class="err">
</span><span class="s">             的自增操作符。C++语言是C 语言的超集，是在C 语言基础上进行的扩展（引入了new、</span><span class="err">
</span><span class="s">             delete 等C 语言中没有的操作符，增加了对面向对象程序设计的直接支持，等等），是先有</span><span class="err">
</span><span class="s">             C 语言，再进行++。根据自增操作符前、后置形式的差别（参见习题5.15 的解答），C++</span><span class="err">
</span><span class="s">             表示对C 语言进行扩展之后，还可以使用C 语言的内容；而写成++C 则表示无法再使用C</span><span class="err">
</span><span class="s">             的原始值了，也就是说C++不能向下兼容C 了，这与实际情况不符。</span><span class="err">
</span><span class="s">         ---------------------*/</span><span class="err">
</span><span class="s">8.箭头操作符(-&gt;)</span><span class="err">
</span><span class="s"> item1.same_isbn(item2);</span><span class="err">
</span><span class="s"> Sales_item *sp=&amp;item1;</span><span class="err">
</span><span class="s"> (*sp).same_isbn(item2);//eq</span><span class="err">
</span><span class="s"> sp-&gt;same_isbn(item2);//eq</span><span class="err">
</span><span class="s">9.条件操作符</span><span class="err">
</span><span class="s"> cond ? expr1 : expr2;</span><span class="err">
</span><span class="s"> // if i&gt;j then maxVal = i else maxVal=j;</span><span class="err">
</span><span class="s"> int maxVal = i&gt;j ? i : j;</span><span class="err">
</span><span class="s">10.sizeof</span><span class="err">
</span><span class="s"> 返回类型 size_t 长度是字节</span><span class="err">
</span><span class="s"> sizeof(type name);</span><span class="err">
</span><span class="s"> sizeof(expr);</span><span class="err">
</span><span class="s"> sizeof expr;</span><span class="err">
</span><span class="s"> 对数组的做sizeof操作返回的是整个数组在内存中的储存长度</span><span class="err">
</span><span class="s">     eg ；求数组元素的个数</span><span class="err">
</span><span class="s">         int sz=sizepf(ia)/sizeof(*ia);</span><span class="err">

</span><span class="s">11.逗号操作</span><span class="err">
</span><span class="s"> int cnt=ivec.size();</span><span class="err">
</span><span class="s"> for(vector&lt;int&gt;::size_type ix=0;ix!=ivec.size();ix++,--cnt)</span><span class="err">
</span><span class="s">     ivec[ix]=cnt;</span><span class="err">
</span><span class="s">12.操作符的优先级</span><span class="err">
</span><span class="s"> p147</span><span class="err">
</span><span class="s">13.new和delete表达式</span><span class="err">
</span><span class="s"> string *ps=new string();</span><span class="err">
</span><span class="s"> int *pi=new int();</span><span class="err">
</span><span class="s"> delete ps;</span><span class="err">
</span><span class="s"> delete pi;</span><span class="err">
</span><span class="s">14.const对象的动态分配和回收</span><span class="err">
</span><span class="s"> //allocate and intialize a const object</span><span class="err">
</span><span class="s"> const int *pci=new const int(1024);</span><span class="err">
</span><span class="s"> //allocate default initialized const empty string</span><span class="err">
</span><span class="s"> const string *pcs=new const string;</span><span class="err">
</span><span class="s">15.删除const对象</span><span class="err">
</span><span class="s"> delete pci;//ok: deletes a const object</span><span class="err">
</span><span class="s">16.类型转换</span><span class="err">
</span><span class="s"> ...</span><span class="err">
</span><span class="s"> ..</span><span class="err">
</span><span class="s"> 忘记保存了蛋疼</span><span class="err">
</span><span class="s"> ..下次补上</span><span class="err">
</span><span class="s"> **</span><span class="err">


</span><span class="s">/*----------------------------------------------------</span><span class="err">
</span><span class="s">第六章    语句</span><span class="err">

</span><span class="s">编译时间：2014-4-3</span><span class="err">
</span><span class="s">完成时间：</span><span class="err">
</span><span class="s">-----------------------------------------------------*/</span><span class="err">
</span><span class="s">1.简单语句</span><span class="err">
</span><span class="s"> 注意空语句;的使用</span><span class="err">
</span><span class="s">2.语句的作用域</span><span class="err">
</span><span class="s"> ;;//略过</span><span class="err">
</span><span class="s"> 块{}</span><span class="err">
</span><span class="s">3.if语句</span><span class="err">
</span><span class="s"> if()</span><span class="err">
</span><span class="s">     {}</span><span class="err">
</span><span class="s"> else if()</span><span class="err">
</span><span class="s">     {}</span><span class="err">
</span><span class="s"> else()</span><span class="err">
</span><span class="s">     {}</span><span class="err">
</span><span class="s"> 悬垂else</span><span class="err">
</span><span class="s">     if语句普遍存在的二义性</span><span class="err">
</span><span class="s">         if()</span><span class="err">
</span><span class="s">             if()</span><span class="err">
</span><span class="s">                 ;</span><span class="err">
</span><span class="s">         else()</span><span class="err">
</span><span class="s">4.switch语句   注意case后面的:不要丢了</span><span class="err">
</span><span class="s"> switch(exper)</span><span class="err">
</span><span class="s"> {</span><span class="err">
</span><span class="s">     case const_1:</span><span class="err">
</span><span class="s">         statement1;</span><span class="err">
</span><span class="s">         statement2;</span><span class="err">
</span><span class="s">          ...</span><span class="err">
</span><span class="s">          break;</span><span class="err">
</span><span class="s">     case const_2:</span><span class="err">
</span><span class="s">         statement1;</span><span class="err">
</span><span class="s">         statement2;</span><span class="err">
</span><span class="s">          ...</span><span class="err">
</span><span class="s">          break;</span><span class="err">
</span><span class="s">     case const_3</span><span class="err">
</span><span class="s">         statement1;</span><span class="err">
</span><span class="s">         statement2;</span><span class="err">
</span><span class="s">          ...</span><span class="err">
</span><span class="s">          break;</span><span class="err">
</span><span class="s">     ...</span><span class="err">
</span><span class="s">     default:</span><span class="err">
</span><span class="s">         statement1;</span><span class="err">
</span><span class="s">         statement2;</span><span class="err">
</span><span class="s">          ...</span><span class="err">
</span><span class="s">          break;</span><span class="err">
</span><span class="s"> }</span><span class="err">
</span><span class="s"> const_n必须是整形常量表达式</span><span class="err">
</span><span class="s">     case 3.14;//erro</span><span class="err">
</span><span class="s">     case ival;//erro</span><span class="err">
</span><span class="s"> 注意不能漏写break 因为执行的是case后面的语句（包括下一个case）直到遇见break结束</span><span class="err">
</span><span class="s"> 但有时候希望执行多个case</span><span class="err">
</span><span class="s">     eg: 计算元音的个数</span><span class="err">
</span><span class="s">         int vowelCnt=0;</span><span class="err">
</span><span class="s">         switch(ch)</span><span class="err">
</span><span class="s">         {</span><span class="err">
</span><span class="s">             case 'a':</span><span class="err">
</span><span class="s">             case 'e':</span><span class="err">
</span><span class="s">             case 'i':</span><span class="err">
</span><span class="s">             case 'o':</span><span class="err">
</span><span class="s">             case 'u':</span><span class="err">
</span><span class="s">                 ++vowelCnt;</span><span class="err">
</span><span class="s">                 break;</span><span class="err">
</span><span class="s">         }</span><span class="err">
</span><span class="s"> switch内部的变量定义</span><span class="err">
</span><span class="s">     case true:</span><span class="err">
</span><span class="s">         {</span><span class="err">
</span><span class="s">             //..</span><span class="err">
</span><span class="s">             string file_name=get_file_name();</span><span class="err">
</span><span class="s">             //..</span><span class="err">
</span><span class="s">         }</span><span class="err">
</span><span class="s">         break;</span><span class="err">
</span><span class="s">     case false:</span><span class="err">
</span><span class="s">         //..</span><span class="err">



</span><span class="s">/*----------------------------------------------------</span><span class="err">
</span><span class="s">第八章I   IO流</span><span class="err">

</span><span class="s">编译时间：2014-4-10</span><span class="err">
</span><span class="s">修改时间：2014-4-10</span><span class="err">
</span><span class="s">-----------------------------------------------------*/      </span><span class="err">
</span><span class="s">定义流对象用于文件的读/写</span><span class="err">
</span><span class="s">    ifstream fin;    //建立输入文件流对象</span><span class="err">
</span><span class="s">    ofstream fout;     //建立输出文件流对象</span><span class="err">
</span><span class="s">    fstream finout;    //建立输入输出文件流对象</span><span class="err">
</span><span class="s">使流对象与文件关联</span><span class="err">
</span><span class="s">    fin.open(“input.txt” , ios::in);   //打开方式能省</span><span class="err">
</span><span class="s">    fout.open(“output.txt” , ios::out);  //打开方式能省</span><span class="err">
</span><span class="s">    finout.open(“inout.txt” , ios::in | ios::out);</span><span class="err">
</span><span class="s">检查文件打开时是否有错</span><span class="err">
</span><span class="s">    if ( in.fail() )…</span><span class="err">
</span><span class="s">检查是否到文件尾</span><span class="err">
</span><span class="s">    if ( in.eof() )…</span><span class="err">

</span><span class="s">带格式读/写</span><span class="err">
</span><span class="s">    fin &gt;&gt; num &gt;&gt; name;</span><span class="err">
</span><span class="s">    fout &lt;&lt; num &lt;&lt; name;</span><span class="err">
</span><span class="s">读/写一个字符</span><span class="err">
</span><span class="s">    ch = fin.get();     //或in.get( ch )</span><span class="err">
</span><span class="s">    fout.put( ch );</span><span class="err">
</span><span class="s">读/写一整行</span><span class="err">
</span><span class="s">    fin.getline(str , n);</span><span class="err">
</span><span class="s">    fout &lt;&lt; str &lt;&lt; endl;</span><span class="err">


</span><span class="s">//文件指针操作--------------------------------------------------</span><span class="err">
</span><span class="s">     #include &lt;iostream&gt;</span><span class="err">
</span><span class="s">     #include &lt;fstream&gt;</span><span class="err">
</span><span class="s">     using namespace std;</span><span class="err">

</span><span class="s">     int main()</span><span class="err">
</span><span class="s">     {</span><span class="err">
</span><span class="s">         int a[10]={1,2,3,4,5,6,7,8,9,10},num;</span><span class="err">
</span><span class="s">         fstream fout,fin;</span><span class="err">
</span><span class="s">         fout.open("</span><span class="n">binary</span><span class="p">.</span><span class="n">dat</span><span class="s">",ios::out|ios::binary);//二进制打开文件</span><span class="err">
</span><span class="s">         for(int i=0;i&lt;10;i++)</span><span class="err">
</span><span class="s">             fout.write((char*)&amp;a[i],sizeof(a[i]));//二进制写非char数据</span><span class="err">
</span><span class="s">         fout.close();</span><span class="err">

</span><span class="s">         fin.open("</span><span class="n">binary</span><span class="p">.</span><span class="n">dat</span><span class="s">",ios::in|ios::binary);</span><span class="err">
</span><span class="s">         fin.seekg(2*sizeof(int),ios::beg);//指针偏移2*4 int为4byte</span><span class="err">
</span><span class="s">         cout&lt;&lt;"</span><span class="err">文件指针当前位置是</span><span class="s">"&lt;&lt;fin.tellg()&lt;&lt;endl;</span><span class="err">
</span><span class="s">         fin.read((char*)&amp;num,sizeof(num));</span><span class="err">
</span><span class="s">         cout&lt;&lt;"</span><span class="err">第三个数是</span><span class="s">"&lt;&lt;num&lt;&lt;endl;</span><span class="err">
</span><span class="s">         cout&lt;&lt;"</span><span class="err">文件指针当前位置是</span><span class="s">"&lt;&lt;fin.tellg()&lt;&lt;endl;</span><span class="err">
</span><span class="s">         fin.close();</span><span class="err">
</span><span class="s">         return 0;</span><span class="err">
</span><span class="s">     }</span><span class="err">
</span><span class="s">//格式化输出</span><span class="err">
</span><span class="s"> #include &lt;iostream&gt;</span><span class="err">
</span><span class="s"> using namespace std;</span><span class="err">

</span><span class="s"> int main()</span><span class="err">
</span><span class="s"> {</span><span class="err">
</span><span class="s">     cout&lt;&lt;"</span><span class="mi">12345678</span> <span class="err">\</span><span class="n">n</span><span class="s">";</span><span class="err">
</span><span class="s">     cout&lt;&lt;12345&lt;&lt;'</span><span class="se">\n</span><span class="s">';</span><span class="err">
</span><span class="s">     cout.width(12);//只对当前输出流有效</span><span class="err">
</span><span class="s">     cout&lt;&lt;12345&lt;&lt;endl;</span><span class="err">
</span><span class="s">     cout.fill('*');</span><span class="err">
</span><span class="s">     cout&lt;&lt;12345&lt;&lt;endl;</span><span class="err">
</span><span class="s">     cout.flags(ios::left);</span><span class="err">
</span><span class="s">     cout.width(12);</span><span class="err">
</span><span class="s">     cout&lt;&lt;12345&lt;&lt;endl;</span><span class="err">
</span><span class="s">     cout.flags(ios::right);</span><span class="err">
</span><span class="s">     cout.width(12);</span><span class="err">
</span><span class="s">     cout&lt;&lt;12345&lt;&lt;endl;</span><span class="err">
</span><span class="s">     return 0;</span><span class="err">
</span><span class="s"> }</span><span class="err">


</span><span class="s"> #include &lt;iostream&gt;</span><span class="err">
</span><span class="s"> #include &lt;iomanip&gt;</span><span class="err">
</span><span class="s"> using namespace std;</span><span class="err">

</span><span class="s"> int main()</span><span class="err">
</span><span class="s"> {</span><span class="err">
</span><span class="s">     cout&lt;&lt;"</span><span class="mo">01234567</span><span class="mi">89</span><span class="err">\</span><span class="n">n</span><span class="s">";</span><span class="err">
</span><span class="s">     cout&lt;&lt;setw(12)&lt;&lt;setfill('*')&lt;&lt;1234&lt;&lt;endl</span><span class="err">
</span><span class="s">         &lt;&lt;setw(12)&lt;&lt;setiosflags(ios::left)&lt;&lt;1234&lt;&lt;endl</span><span class="err">
</span><span class="s">         &lt;&lt;setw(12)&lt;&lt;resetiosflags(ios::left)&lt;&lt;1234&lt;&lt;endl</span><span class="err">
</span><span class="s">         &lt;&lt;setw(12)&lt;&lt;setfill('$')&lt;&lt;setprecision(5)&lt;&lt;12.34567&lt;&lt;endl;</span><span class="err">
</span><span class="s">     return 0;</span><span class="err">
</span><span class="s"> }</span><span class="err">

</span><span class="s">//stringstream 对象</span><span class="err">
</span><span class="s"> #include &lt;iostream&gt;</span><span class="err">
</span><span class="s"> #include &lt;sstream&gt;</span><span class="err">
</span><span class="s"> using namespace std;</span><span class="err">
</span><span class="s"> int main()</span><span class="err">
</span><span class="s"> {</span><span class="err">
</span><span class="s">     string word,line;</span><span class="err">
</span><span class="s">     istringstream format_message;</span><span class="err">
</span><span class="s">     while(getline(cin,line))</span><span class="err">
</span><span class="s">     {</span><span class="err">
</span><span class="s">         format_message.clear();</span><span class="err">
</span><span class="s">         format_message.str(line);//复制line返回给format_message</span><span class="err">
</span><span class="s">         while(format_message&gt;&gt;word)</span><span class="err">
</span><span class="s">             cout&lt;&lt;word&lt;&lt;endl;</span><span class="err">
</span><span class="s">     }</span><span class="err">

</span><span class="s">     return 0;</span><span class="err">
</span><span class="s"> }</span><span class="err">
</span><span class="s">//综合 p258 x_8.16</span><span class="err">
</span><span class="s">#include &lt;iostream&gt;</span><span class="err">
</span><span class="s">#include &lt;fstream&gt;</span><span class="err">
</span><span class="s">#include &lt;sstream&gt;</span><span class="err">
</span><span class="s">#include &lt;vector&gt;</span><span class="err">

</span><span class="s">using namespace std;</span><span class="err">

</span><span class="s">int main()</span><span class="err">
</span><span class="s">{</span><span class="err">
</span><span class="s">    vector&lt;string&gt; ivec;</span><span class="err">
</span><span class="s">    string s;</span><span class="err">
</span><span class="s">    fstream fio;</span><span class="err">
</span><span class="s">    istringstream si;</span><span class="err">
</span><span class="s">    fio.open("</span><span class="n">x_8</span><span class="mf">.15</span><span class="p">.</span><span class="n">txt</span><span class="s">",ios::out);</span><span class="err">
</span><span class="s">    while(getline(cin,s))</span><span class="err">
</span><span class="s">        fio&lt;&lt;s&lt;&lt;endl;</span><span class="err">
</span><span class="s">    fio.close();</span><span class="err">
</span><span class="s">    fio.open("</span><span class="n">x_8</span><span class="mf">.15</span><span class="p">.</span><span class="n">txt</span><span class="s">",ios::in);</span><span class="err">
</span><span class="s">    while(!fio.eof())</span><span class="err">
</span><span class="s">    {</span><span class="err">
</span><span class="s">        fio&gt;&gt;s;</span><span class="err">
</span><span class="s">        ivec.push_back(s);</span><span class="err">
</span><span class="s">    }</span><span class="err">
</span><span class="s">    for(vector&lt;string&gt;::iterator iter=ivec.begin();iter!=ivec.end()-1;iter++)</span><span class="err">
</span><span class="s">    {</span><span class="err">
</span><span class="s">        si.clear();</span><span class="err">
</span><span class="s">        si.str(*iter);</span><span class="err">
</span><span class="s">        while(si&gt;&gt;s)</span><span class="err">
</span><span class="s">            cout&lt;&lt;s&lt;&lt;endl;</span><span class="err">
</span><span class="s">    }</span><span class="err">
</span><span class="s">    return 0;</span><span class="err">
</span><span class="s">}</span><span class="err">

</span><span class="s">/*----------------------------------------------------</span><span class="err">
</span><span class="s">第九章 顺序容器</span><span class="err">

</span><span class="s">编译时间：2014-4-10</span><span class="err">
</span><span class="s">修改时间：2014-4-10</span><span class="err">
</span><span class="s">-----------------------------------------------------*/</span><span class="err">
</span><span class="s">三种迭代器</span><span class="err">
</span><span class="s"> vector</span><span class="err">
</span><span class="s"> deque</span><span class="err">
</span><span class="s"> list::迭代器 只支持自增自减和不等</span><span class="err">


</span><span class="s">/*----------------------------------------------------</span><span class="err">
</span><span class="s">第十章    关联容器</span><span class="err">

</span><span class="s">编译时间：2014-4-11</span><span class="err">
</span><span class="s">修改时间：</span><span class="err">
</span><span class="s">-----------------------------------------------------*/</span><span class="err">
</span><span class="s">//map容器 记录入单词出现的次数</span><span class="err">
</span><span class="s"> #include &lt;iostream&gt;</span><span class="err">
</span><span class="s"> #include &lt;map&gt;</span><span class="err">
</span><span class="s"> using namespace std;</span><span class="err">

</span><span class="s"> int main()</span><span class="err">
</span><span class="s"> {</span><span class="err">
</span><span class="s">     map&lt;string,int&gt; word_count;</span><span class="err">
</span><span class="s">     string word;</span><span class="err">
</span><span class="s">     while(cin&gt;&gt;word)</span><span class="err">
</span><span class="s">     {</span><span class="err">
</span><span class="s">        ++word_count[word];</span><span class="err">
</span><span class="s">     }</span><span class="err">
</span><span class="s">     map&lt;string,int&gt;::iterator miter=word_count.begin();</span><span class="err">
</span><span class="s">     while(miter!=word_count.end())</span><span class="err">
</span><span class="s">     {</span><span class="err">
</span><span class="s">         cout&lt;&lt;miter-&gt;first&lt;&lt;"</span> <span class="s">"&lt;&lt;miter-&gt;second&lt;&lt;endl;</span><span class="err">
</span><span class="s">         miter++;</span><span class="err">
</span><span class="s">     }</span><span class="err">

</span><span class="s">     return 0;</span><span class="err">
</span><span class="s"> }</span><span class="err">
</span><span class="s"> </span></code></pre></figure>
</span>

       

        
        <div class="tags">
          <small>
          <i class="fa fa-tags"></i>
            c++, 学习笔记
          </small>
        </div>
        

      </div>

      <div class="content-panel feedback">

       如果你对此文章有更好的想法请 <a href="http://weibo.com/SuDoYc" target="_blank"><i class="fa fa-weibo"></i>ychost-wb</a> 或者直接在下面评论!
      </div>

      
    <!-- UY BEGIN -->
        <div id="uyan_frame"></div>
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2075696"></script>
    <!-- UY END -->

     
      

    </div>

  </div>

</div>

      </div>
    </div>

    <div class="footer clearfix">
  <div class="col-md-6">
    楔子 <i class="fa fa-heart"></i>  <a target="_new" href="http://weibo.com/SuDoYc">八千里路</a>
  </div>
  <div class="col-md-6">
    &lt;/&gt; on <a target="_new " href="https://github.com/ychost">Github</a> &nbsp;<i class="fa fa-github-alt"></i>
  </div>
</div>

<script src="/js/bootstrap.mini.js"></script>
<script src="/js/jquery.mmenu.min.all.js"></script>
<script src="/js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">

  $(function(){

  //MSIE 为IE11以下的检测，Trident.*rv[ :]*11\.为IE
    if( /Android|webOS|iPhone|iPad|iPod|MSIE |Trident.*rv[ :]*11\.|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
              addOrginalFont();
     }else{
               addLsFont();
     }

      $("#my-menu").mmenu().on( "closed.mm", function() {
            $(".menu-button").show();
         });
      $(".menu-button").click(function() {
        $(".menu-button").hide();
        $("#my-menu").trigger("open.mm");
      });
      //2015-12-12 12:18:56，关闭导航
      $(".my-home").click(function() {
        $("#my-menu").trigger("close.mm");
      });
   });
</script>



<script type="text/javascript">

function addLsFont(){
try {
    if (localStorage.chenjishi) {
        // 如果localStorage中有该字体，就直接取出来加载
        addFont(localStorage.getItem("chenjishi"));
    } else {

        // 首次加载字体我们需要异步加载它
        $.get("/font/xingshu/chenjishi.css", function(result){
          // localStorage.chenjishi = result;
          localStorage.setItem('chenjishi', result);
           addFont(result);
      });
    }
  }catch(err){
      alert("请在电脑上用谷歌或者火狐浏览器吧，你这浏览器加载出来的不能忍");
   }
 }
 function addFont(cssString) {
   var doc=document;
       var style=doc.createElement("style");
       style.setAttribute("type", "text/css");

       if(style.styleSheet){// IE
           style.styleSheet.cssText = cssString;
       } else {// w3c
           var cssText = doc.createTextNode(cssString);
           style.appendChild(cssText);
       }
       var heads = doc.getElementsByTagName("head");
       if(heads.length)
           heads[0].appendChild(style);
       else
           doc.documentElement.appendChild(style);
 }


function addOrginalFont(){
  $.get("/font/xingshu/OrginalTTF.css", function(result){
     addFont(result);
});
}

</script>

    </body>
</html>
